<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言基础——浅谈函数及程序结构 | Welcome to xinghai！</title><meta name="author" content="Hepel Yan"><meta name="copyright" content="Hepel Yan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="函数与程序结构一、作用域的基本概念 1、什么叫做对于定义的变量作用区域的识别？1234567891011121314151617181920#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123;	int i;	int a &#x3D; 1, b &#x3D; 2; 		&#x2F;&#x2F;定义在第一个作用域中，也就是主函数作用域里	&#x2F;&#x2F;所以只要是在主函">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言基础——浅谈函数及程序结构">
<meta property="og:url" content="https://github.com/yanhaiping123/hexo-hepel-blog/2024/08/08/Functions%20and%20program%20structures/index.html">
<meta property="og:site_name" content="Welcome to xinghai！">
<meta property="og:description" content="函数与程序结构一、作用域的基本概念 1、什么叫做对于定义的变量作用区域的识别？1234567891011121314151617181920#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123;	int i;	int a &#x3D; 1, b &#x3D; 2; 		&#x2F;&#x2F;定义在第一个作用域中，也就是主函数作用域里	&#x2F;&#x2F;所以只要是在主函">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2024/08/08/qLVOClrzsFo26Wb.jpg">
<meta property="article:published_time" content="2024-08-08T06:37:18.046Z">
<meta property="article:modified_time" content="2024-08-08T06:47:34.311Z">
<meta property="article:author" content="Hepel Yan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/08/08/qLVOClrzsFo26Wb.jpg"><link rel="shortcut icon" href="/yanhaiping123/hexo-hepel-blog/img/favicon.png"><link rel="canonical" href="https://github.com/yanhaiping123/hexo-hepel-blog/2024/08/08/Functions%20and%20program%20structures/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/yanhaiping123/hexo-hepel-blog/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/yanhaiping123/hexo-hepel-blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言基础——浅谈函数及程序结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-08-08 14:47:34'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2024/08/08/qLVOClrzsFo26Wb.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/yanhaiping123/hexo-hepel-blog/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/yanhaiping123/hexo-hepel-blog/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/yanhaiping123/hexo-hepel-blog/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/yanhaiping123/hexo-hepel-blog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/yanhaiping123/hexo-hepel-blog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2024/08/08/7gbvi2U5YpSGAWd.jpg')"><nav id="nav"><span id="blog-info"><a href="/yanhaiping123/hexo-hepel-blog/" title="Welcome to xinghai！"><img class="site-icon" src="https://s2.loli.net/2024/08/08/qLVOClrzsFo26Wb.jpg"/><span class="site-name">Welcome to xinghai！</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/yanhaiping123/hexo-hepel-blog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/yanhaiping123/hexo-hepel-blog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/yanhaiping123/hexo-hepel-blog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言基础——浅谈函数及程序结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-08-08T06:37:18.046Z" title="Created 2024-08-08 14:37:18">2024-08-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-08-08T06:47:34.311Z" title="Updated 2024-08-08 14:47:34">2024-08-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言基础——浅谈函数及程序结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="函数与程序结构"><a href="#函数与程序结构" class="headerlink" title="函数与程序结构"></a>函数与程序结构</h1><h2 id="一、作用域的基本概念"><a href="#一、作用域的基本概念" class="headerlink" title="一、作用域的基本概念"></a>一、作用域的基本概念</h2><p><img src=".\image\作用域.png" alt=""></p>
<h5 id="1、什么叫做对于定义的变量作用区域的识别？"><a href="#1、什么叫做对于定义的变量作用区域的识别？" class="headerlink" title="1、什么叫做对于定义的变量作用区域的识别？"></a>1、什么叫做对于定义的变量作用区域的识别？</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>; 	</span><br><span class="line">	<span class="comment">//定义在第一个作用域中，也就是主函数作用域里</span></span><br><span class="line">	<span class="comment">//所以只要是在主函数中，我们可以自由的访问这两个变量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>; <span class="comment">//定义在第二个作用域中</span></span><br><span class="line">		<span class="comment">//所以我们只能再for循环后面的小作用域中去访问c和d这两个变量</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子作用域：%d %d\n&quot;</span>, a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// printf(&quot;%d %d\n&quot;, c, d);</span></span><br><span class="line">	<span class="comment">// 注意：主作用域不能访问子作用域的变量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;主作用域：%d %d\n&quot;</span>, a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src=".\image\错误：主作用域访问子作用域.png" alt=""></p>
<p>注意：主作用域不能访问子作用域的变量。以上是报错信息。但是任何子作用域都可以访问主作用域。</p>
<h2 id="二、函数的定义和使用"><a href="#二、函数的定义和使用" class="headerlink" title="二、函数的定义和使用"></a>二、函数的定义和使用</h2><p>首先，在C语言中，一个函数一般包括返回值类型、函数名（自定义，也可以调用库函数，即C语言或者系统自带的库函数）、参数列表、函数体（就是由大括号包裹的相关表达式、运算符、返回值等）这四个部分组成。</p>
<p><img src=".\image\函数基本结构.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="comment">// 随机键入两个数值</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum:%d\n&quot;</span>, sum(a,b));</span><br><span class="line">	<span class="comment">// 通过调用自定义sum函数传入两个值a和b,即,sum(a,b)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sub:%d\n&quot;</span>, sub(a,b));	</span><br><span class="line">	<span class="comment">// 通过调用自定义sub函数传入两个值a和b,即,sub(a,b)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 以上函数实现比较简单，我就不一一分析代码了 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思考1：接下来有一个需求，要我们传入两个值，第一个值是target，第二个值是x；当target=1时，函数返回根号x的值；当target=2时，返回x的平方的值。x是一个浮点值，故此，函数返回值也应是浮点值。</p>
<ul>
<li>首先，第一步，我们已知这个函数的返回值是一个浮点值，所以返回值类型是double；</li>
<li>其次，就是为我们的函数取一个闪亮的名字（方便我们记忆），适合自己的就好，我的就叫test_function；</li>
<li>然后就是，我们这个函数所传入的参数（也就是上图说到的参数列表），我们可以根据题意中，我们需要传入的参数是target和x，target的类型是整型int，x的类型是浮点型double；</li>
<li>现在，我们的函数已经具备了返回值类型、函数名、参数列表，就只剩下函数体了。那么在函数体内部，我们需要做出一个判断，判断当target=1时，函数返回根号x的值；当target=2时，返回x的平方的值；这里可以使用if-else，也可以使用switch-case，但是使用switch-case肯定会让我们的代码看起来更简洁、也更方便。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="comment">// c语言数学库，最后我们要通过gcc -o func01 func01.c -lm命令编译并链接数学库</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">test_function</span><span class="params">(<span class="type">int</span> target, <span class="type">double</span> x)</span>; <span class="comment">//这个是函数声明，也可以不写</span></span><br><span class="line"><span class="comment">//但是之后通过在一个文件调用另一个文件的函数时，必须要先声明再调用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sqrt(3)=%lf\n&quot;</span>, test_function(<span class="number">1</span>,<span class="number">3</span>));	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;11 of square is %lf\n&quot;</span>, test_function(<span class="number">2</span>,<span class="number">11</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里的1和2代表target,3和11代表x</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">test_function</span><span class="params">(<span class="type">int</span> target, <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(target) <span class="comment">// 这里做一个判断，target为１,则打印根号ｘ</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> <span class="built_in">sqrt</span>(x); </span><br><span class="line">			<span class="comment">//sqrt(x):sqrt是包含在math头文件中的一个数学函数，可以通过man 3 sqrt查看该手册</span></span><br><span class="line">			<span class="comment">// The  sqrt () function returns the nonnegative square root of  x .</span></span><br><span class="line">			<span class="comment">// 翻译:函数的作用是返回一个非负平方根．</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">return</span> x * x;</span><br><span class="line">			<span class="comment">// target为2,则打印x的平方</span></span><br><span class="line">			<span class="comment">// printf(&quot;%lf of square is %lf\n&quot;, x, x * x);</span></span><br><span class="line">			<span class="comment">// break;</span></span><br><span class="line">		<span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;error target\n&quot;</span>); </span><br><span class="line">			<span class="comment">// 如果都不成立，则打印一个错误</span></span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 注意:记得写返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src=".\image\思考-error解析.png"  /></p>
<p><img src=".\image\思考-结果.png" alt=""></p>
<p>上图有两个错误以及一个编译带有数学库函数的一个相关命令。首先，第一个方框是表示，编译器找不到sqrt函数的定义，我们只好通过链接数学函数库来试一下，就是后面的gcc -o func01 func01.c -lm命令。然后，第二个方框是没有找到ld这个链接库，或者是sqrt不在这个库里面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o func01 func01.c -lm</span><br></pre></td></tr></table></figure>
<p>思考2：假设现在我们又要传入一个n，打印n次hello world，那么这个功能该如何来实现呢？</p>
<ul>
<li>首先，依旧是那函数的四个部分，学会读函数、写函数，我们首先就要掌握好函数的四要素。然后，对于这个函数的返回值类型，题目中提到了打印n次hello world，那肯定是int类型啊；但是，即使是int，我们以及知道了它的返回值是int n，那么前面的返回值类型便失去了意义；而C语言里有专门的无意义的返回类型，那就是void；</li>
<li>其次，函数名，还是那句话，去一个自己能够辨识的名字，别到时候自己都不认识。我这里就叫print_hello_world();</li>
<li>再者，函数的参数也很显然，就是一个整型n(int n)；</li>
<li>最后，函数体，我这里可以给它一个for循环。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hello_world</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">	<span class="comment">// a = scanf(&quot;%d&quot;, &amp;a); 这个表示scanf读取数的个数，而不是本身，需要注意一下</span></span><br><span class="line">	<span class="comment">// 我已经跳坑了</span></span><br><span class="line"></span><br><span class="line">	print_hello_world(a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hello_world</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src=".\image\思考2-循环helloworld.png" alt=""></p>
<h2 id="三、为什么一定要有函数结构"><a href="#三、为什么一定要有函数结构" class="headerlink" title="三、为什么一定要有函数结构"></a>三、为什么一定要有函数结构</h2><p>我们现在写的程序以及现在的代码量还不是很大，大不了多用几个printf，或者多写几个表达式，但如果以后我们有开发需求，那庞大的代码量，才是最头疼的。而函数的出现，就已经解决这个问题，以后出现重复性高的代码，我们直接封装一个函数，通过反复调用这个函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arithmetic_sequence_sum</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> r, <span class="type">int</span> d)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; %d\n %d\n %d\n %d\n %d\n&quot;</span>, arithmetic_sequence_sum(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>),</span><br><span class="line">								arithmetic_sequence_sum(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>),</span><br><span class="line">								arithmetic_sequence_sum(<span class="number">1</span>, <span class="number">100</span>, <span class="number">3</span>),</span><br><span class="line">								arithmetic_sequence_sum(<span class="number">1</span>, <span class="number">100</span>, <span class="number">4</span>),</span><br><span class="line">								arithmetic_sequence_sum(<span class="number">26</span>, <span class="number">36999</span>, <span class="number">47</span>)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arithmetic_sequence_sum</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> r, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Arithmetic sequence:等差数列的英文</span></span><br><span class="line">	<span class="comment">// a1:首项 r:范围（尾项） d:公差</span></span><br><span class="line">    <span class="comment">// 只需一个函数，上面即可多次调用该函数，简单方便，且高效编程</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n, an;</span><br><span class="line"></span><br><span class="line">	n = (r - a1) / d + <span class="number">1</span>;</span><br><span class="line">	an = a1 +  (n - <span class="number">1</span>) * d;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (a1 + an) * n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四、实参与形参（真假孙悟空）"><a href="#四、实参与形参（真假孙悟空）" class="headerlink" title="四、实参与形参（真假孙悟空）"></a>四、实参与形参（真假孙悟空）</h2><p>实参：就是实实在在存在的一个参数，一般为具体的一个数值，主要指调用的时候所传入的那个参数（真孙悟空）；</p>
<p>形参：一般是来接收（接替）实参的一个参数，主要是指我们创建函数时，在参数列表里的参数（六耳猕猴）；</p>
<h5 id="注意：形参的所有改变都不会改变实参的值。"><a href="#注意：形参的所有改变都不会改变实参的值。" class="headerlink" title="注意：形参的所有改变都不会改变实参的值。"></a>注意：形参的所有改变都不会改变实参的值。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//因为我这几个程序都是把函数写在最后面</span></span><br><span class="line"><span class="comment">//但是不声明一下会报错，我们也可以直接把函数写在main函数前面</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	test_func(a, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main:\na = %d\nb = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	a += b;</span><br><span class="line">	b *= <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main:\na = %d\nb = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上程序我们只是吧实参里面的值给了形参，实参依旧是实参。然而，当我们在调用test_func这个函数的过程中，我们的参数赋值的过程，就是一个按位进行赋值的过程，也就是它们是一一对应的进行赋值，如，在主函数test_func(a, b)中，把a的值给了形参a，b的值给了形参b；相反，test_func(b, a)中，把b的值给了形参a，a的值给了形参b。</p>
<h2 id="五、函数的定义与声明"><a href="#五、函数的定义与声明" class="headerlink" title="五、函数的定义与声明"></a>五、函数的定义与声明</h2><p>函数的定义：也就是整个函数的实现过程。上面讲过函数的定义的四要素，返回值类型、函数名、参数列表、函数体。</p>
<p>函数的声明：也就是告诉我们的程序，我们要使用这个函数。相当于写一个告示（或者皇上昭告天下，让每一个老百姓悉知）。具体形式如下图所示：</p>
<p><img src=".\image\函数的声明.png" alt=""></p>
<p>那么，函数的声明具体有啥作用呢？</p>
<p>注意：在调用函数之前，我们没有必要知道函数的定义，但一定要知道函数的声明。（连名字都不知道，怎么有交集？）</p>
<p><img src=".\image\函数声明的作用.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译结果：</span></span><br><span class="line"><span class="comment">linux@linux:~/code/function/scope$ gcc dfun.c </span></span><br><span class="line"><span class="comment">linux@linux:~/code/function/scope$ ./a.out </span></span><br><span class="line"><span class="comment">3 * x = 3</span></span><br><span class="line"><span class="comment">2 * x = 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="六、递归函数（基础讲解）"><a href="#六、递归函数（基础讲解）" class="headerlink" title="六、递归函数（基础讲解）"></a>六、递归函数（基础讲解）</h2><p>递归函数：也就是自己调用自己的函数。</p>
<p><img src=".\image\5的阶乘图解.png" alt=""></p>
<p>注意：这一步因为是有f1调用f2，f2调用f3……等过程，我们称之为递归向下。</p>
<p><img src=".\image\5的阶乘图解二.png" alt=""></p>
<p>注意：当由后面的函数向前面的返回的过程，我们称之为回溯。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in f(%d)\n&quot;</span>, n);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) ret = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> ret = n * f(n - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;out f(%d)\n&quot;</span>, n);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *while (~scanf(&quot;%d&quot;, &amp;n)) 这行代码在C编程中是一个常见的用法，用于从用户那里读取整数输入，</span></span><br><span class="line"><span class="comment">	 直到用户输入无效的输入（通常是按下EOF，表示“文件结束”）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 ~ 是C语言中的位非运算符。当应用于一个整数时，它会翻转该整数二进制表示中的所有位。</span></span><br><span class="line"><span class="comment">	 在这个情况下，输入 n 应该是一个整数，所以 scanf 将尝试从标准输入流（通常是键盘）读取一个整数。</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">	 如果输入是一个有效的整数，scanf 将返回1，表示成功。</span></span><br><span class="line"><span class="comment">	 否则，如果输入不是一个有效的整数或者输入流的末尾已经被到达，scanf 将返回0，表示失败。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 while (~scanf(&quot;%d&quot;, &amp;n)) 的含义是：只要 scanf 成功读取了一个整数，并且其结果的按位非值不等于0（即原值为1），</span></span><br><span class="line"><span class="comment">	 就会继续循环。这意味着只要能够正确地读取一个整数，就会一直进行循环。当无法再读取到有效的整数时，循环将会终止。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;f(%d) = %d\n&quot;</span>, n, f(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src=".\image\5的阶乘运行结果.png" alt=""></p>
<h3 id="1、分析斐波那契数列函数"><a href="#1、分析斐波那契数列函数" class="headerlink" title="1、分析斐波那契数列函数"></a>1、分析斐波那契数列函数</h3><p>首先，我们在做这道题目前，就要先来了解一下什么是斐波那契数列？即使我们没有概念，那也不难知道，斐波那契数列就是0，1，1，2，3，5，8，13，21，34，……，这样一个数列。它的规律就是从第三项开始，它就是前两项之和得到的。故此，我们可以假设n为它的项数，当n=1或者n=2时，即，可以得到前两项都为1；然后后面的就是，假设我们要求第四项（因为前三项我们已知了），那么F(n)=F(n-1)+F(n-2)，因为n=4，F(n-1)=3（就是第三项），F(n-2)（就是第二项），刚好是前两项之和，故此，我们可以把F(n)=F(n-1)+F(n-2)称之为该函数的递归公式。好，下面来看看斐波那契的通项公式：</p>
<p><img src=".\image\斐波那契通项公式.png" alt=""></p>
<p>这个公式如果大家感兴趣，可以自己去查阅相关资料，自己推导推导。现在，根据以上的赘述，我们可以得出几条关于斐波那契数列的性质：</p>
<ul>
<li>每一个数字是前两个数字之和；</li>
<li>每一个数字都是前一个数字的两倍减去前两个数字之差；</li>
<li>除了前三项之外，后面的每一项都是该项的前两项之和。</li>
</ul>
<p><img src=".\image\斐波那契数列简单调用.png" alt=""></p>
<p>当然了，如果我们平常根据上述演示来写程序，那实在是太麻烦了！这里我们可以通过树状图的方式来分析一个递归结构。</p>
<p><img src=".\image\递归树状图分析.png" style="zoom:80%;" /></p>
<h3 id="2、欧几里得算法"><a href="#2、欧几里得算法" class="headerlink" title="2、欧几里得算法"></a>2、欧几里得算法</h3><p>欧几里得算法是用于计算两个非负整数最大公约数（GCD）的一种古老而高效的算法。因为该算法最早出现在古希腊数学家欧几里得的著作《几何原本》中，故此而称之为欧几里得算法。</p>
<p>最大公约数就是，同时能够整除两个数字的最大的那个数，我们称之为最大公约数。假设有两个整数a和b，故它们的最大公约数表示为gcd(a, b)。下面我们看一下欧几里得算法的具体实现流程：</p>
<ul>
<li>1）输入：两个非负整数a和b，其中a &gt;= b;</li>
<li>2）如果b=0，则返回a作为结果，因为这是的a就是两个数的最大公约数；</li>
<li>3）否则，我们将a除以b得到remainder（r，余数）；</li>
<li>4）用较小的数b替换原来的a，用余数r替换原来的b；</li>
<li>5）重复第2~4步骤，直到b=0为止。</li>
</ul>
<p><img src=".\image\欧几里得实例.png" style="zoom:80%;" /></p>
<h3 id="3、递归函数的终极奥义（难点）"><a href="#3、递归函数的终极奥义（难点）" class="headerlink" title="3、递归函数的终极奥义（难点）"></a>3、递归函数的终极奥义（难点）</h3><p>首先，我们前面学的递归还是很容易理解的，毕竟代码量也少，方便我们画图进行理解性记忆。但是，从这里开始，我们不能再见一个递归函数就画一个树状图了，要是在一个庞大的C语言项目中，难道也要一个一个来画树状图来理解？而现在我们要思考的是，递归函数的本质是什么？从这里开始学习，大家需要有下面的相关知识储备：</p>
<h4 id="1）数学归纳法"><a href="#1）数学归纳法" class="headerlink" title="1）数学归纳法"></a>1）数学归纳法</h4><ul>
<li>第一步：验证P(1)，命题成立；</li>
<li>第二步：证明如果P(k)命题成立，那么P(k+1)命题也成立；</li>
<li>第三步：联立第一步与第二步，证明由P(1)到P(n)命题都成立。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i; 	<span class="comment">//这是对for循环中的i变量初始化,但是c99可以在for循环里面初始化</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//这是一个初始条件,代表前０项之和</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *数学归纳法：</span></span><br><span class="line"><span class="comment"> 1.我们假设进入到循环之前的（也就是这些变量的初始化）称为P(1),这里sum为P(1);</span></span><br><span class="line"><span class="comment"> 2.然后就是i，sum每次代表前k项的和，那么i就代表前k+1的和，也可以认为是前i项的和;</span></span><br><span class="line"><span class="comment"> 3.再然后，我们联立这两步;</span></span><br><span class="line"><span class="comment"> 4.在编程思维中，不叫数学归纳法，而是结构归纳法.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2）递归函数设计的三要素"><a href="#2）递归函数设计的三要素" class="headerlink" title="2）递归函数设计的三要素"></a>2）递归函数设计的三要素</h4><ul>
<li>给递归函数一个明确的解释（可以先不考虑如何实现，但一定要是一个明确的解释）；</li>
<li>递归函数的边界条件（相当于前面数学归纳法的P(1)）；</li>
<li>假设递归函数调用的返回结果是正确的，实现本层函数逻辑（相当于P(k) -&gt; P(k+1)）;</li>
</ul>
<h4 id="3）利用递归求阶乘"><a href="#3）利用递归求阶乘" class="headerlink" title="3）利用递归求阶乘"></a>3）利用递归求阶乘</h4><p>见上面5的阶乘实现！</p>
<h2 id="七、关于函数的扩展知识"><a href="#七、关于函数的扩展知识" class="headerlink" title="七、关于函数的扩展知识"></a>七、关于函数的扩展知识</h2><h3 id="1、扩展欧几里得算法"><a href="#1、扩展欧几里得算法" class="headerlink" title="1、扩展欧几里得算法"></a>1、扩展欧几里得算法</h3><h4 id="什么是贝祖等式？"><a href="#什么是贝祖等式？" class="headerlink" title="什么是贝祖等式？"></a>什么是贝祖等式？</h4><p>贝祖等式（Bézout’s Identity或Bézout’s Lemma）是初等数论中的一个定理，它描述了两个整数的最大公约数（Greatest Common Divisor，GCD）与这两个整数之间的线性组合的关系。该定理由18世纪的法国数学家艾蒂安·贝祖（Étienne Bézout）提出。</p>
<h5 id="贝祖等式的形式如下："><a href="#贝祖等式的形式如下：" class="headerlink" title="贝祖等式的形式如下："></a>贝祖等式的形式如下：</h5><p>如果a和b是整数，且d是它们的最大公约数，则存在整数x和y使得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax + by = d		&lt;=&gt; 	ax+by = gcd(a,b) = c</span><br></pre></td></tr></table></figure>
<p>这意味着对于任意给定的a、b和它们的最大公约数d，总能找到一对整数x和y满足上述等式。特别地，当a和b互质（即最大公约数为1）时，我们可以找到一组x和y使得ax + by = 1，这被称为贝祖配对。</p>
<p>这个定理在许多领域都有应用，特别是在计算理论、密码学和算法设计中。例如，在中国剩余定理的求解过程中，贝祖等式是一个重要的工具。此外，它也是理解欧几里得算法如何工作的一个关键部分，因为欧几里得算法实际上是在寻找满足贝祖等式的x和y值的过程。</p>
<p><img src=".\image\贝祖等式.png" style="zoom:80%;" /></p>
<p>黄色部分相当于是扩展欧几里得算法的最后一层。也就是当b=0时。是很容易得到x=1，y=0这样一组解的。然后到了最后一层就会直接返回一个a，也就是a和b的最大公约数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, y, nx, ny;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ex_gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> c = ex_gcd(b, a % b);</span><br><span class="line">	nx = y;</span><br><span class="line">	ny = x - a / b * y;</span><br><span class="line">	x = nx, y = ny;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">		<span class="type">int</span> c = ex_gcd(a, b);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d * %d + %d * %d = %d\n&quot;</span>, a, x, b, y, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src=".\image\贝祖等式-运行结果.png" style="zoom:80%;" /></p>
<h3 id="2、变参函数"><a href="#2、变参函数" class="headerlink" title="2、变参函数"></a>2、变参函数</h3><p>在C语言中，可以使用变参函数来处理不定数量的参数。变参函数的一个常见例子是<code>printf()</code>和<code>scanf()</code>函数。</p>
<p>要声明一个变参函数，你需要指定最后一个输入参数为<code>...</code>（三个点），这表示该函数可以接受任意数量的参数。然后，在函数内部，你可以使用<code>va_list</code>、<code>va_start</code>、<code>va_arg</code>和<code>va_end</code>等宏来访问这些参数。</p>
<p>下面是一个简单的变参函数示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_numbers</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    va_list args;  <span class="comment">//如何获取count往后的参数列表？va_list类型的变量</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    va_start(args, count); <span class="comment">// 初始化va_list（如何定位count后面的第一个参数的位置）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, va_arg(args, <span class="type">int</span>)); <span class="comment">// 获取下一个整数参数并输出（如何获取下一个可变参数列表中的参数）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(args); <span class="comment">// 清理va_list（如何结束整个获取可变参数列表的动作）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    print_numbers(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">print_numbers函数接受一个整数count作为第一个参数，后面跟着任意数量的整数。它通过va_arg宏获取每个整数参数，并将其输出到屏幕上。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，由于变参函数的特性，你必须知道如何正确地解析传入的参数类型。如果传递了错误类型的参数或不正确的参数数量，程序可能会出现未定义的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="3、主函数也是有参数的"><a href="#3、主函数也是有参数的" class="headerlink" title="3、主函数也是有参数的"></a>3、主函数也是有参数的</h3><p>写了这么久的主函数了，相信我们也和这四俩很熟悉了。一起来看看吧！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> **env)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>argc</code>（argument count）是一个整数，表示命令行参数的个数，包括程序名称本身；<code>argv</code>（argument vector）是一个字符指针数组，每个元素指向一个字符串，这些字符串就是命令行参数。</p>
<p>例如，如果你运行程序的方式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out arg1 arg2 arg3</span><br></pre></td></tr></table></figure>
<p>那么，<code>argc</code>的值就是4（包括程序名’a.out’），<code>argv[0]</code>指向字符串”a.out”，<code>argv[1]</code>指向字符串”arg1”，<code>argv[2]</code>指向字符串”arg2”，<code>argv[3]</code>指向字符串”arg3”。</p>
<h5 id="注意，虽然主函数可以有参数，但并不是所有的编程环境都支持这种特性。在一些嵌入式系统或者某些特定的编程环境中，主函数可能不接受任何参数。"><a href="#注意，虽然主函数可以有参数，但并不是所有的编程环境都支持这种特性。在一些嵌入式系统或者某些特定的编程环境中，主函数可能不接受任何参数。" class="headerlink" title="注意，虽然主函数可以有参数，但并不是所有的编程环境都支持这种特性。在一些嵌入式系统或者某些特定的编程环境中，主函数可能不接受任何参数。"></a>注意，虽然主函数可以有参数，但并不是所有的编程环境都支持这种特性。在一些嵌入式系统或者某些特定的编程环境中，主函数可能不接受任何参数。</h5></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://github.com/yanhaiping123/hexo-hepel-blog">Hepel Yan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://github.com/yanhaiping123/hexo-hepel-blog/2024/08/08/Functions%20and%20program%20structures/">https://github.com/yanhaiping123/hexo-hepel-blog/2024/08/08/Functions and program structures/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/08/08/qLVOClrzsFo26Wb.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/yanhaiping123/hexo-hepel-blog/2024/08/07/hello-world/" title="Welcome to XingHai!"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Welcome to XingHai!</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/08/08/qLVOClrzsFo26Wb.jpg" onerror="this.onerror=null;this.src='/yanhaiping123/hexo-hepel-blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hepel Yan</div><div class="author-info__description">This a Webside that blends arts and science. Not only the beauty of science and technology, but also the care of human geography! Thirst for knowledge! Worship wisdom! May be correct, may be absurd, there are many shortcomings, but also hope to teach (three people, there will be my teacher). You are also welcome to come to us to share your feelings at a certain moment.</div></div><div class="card-info-data site-data is-center"><a href="/yanhaiping123/hexo-hepel-blog/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/yanhaiping123/hexo-hepel-blog/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/yanhaiping123/hexo-hepel-blog/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" href="https://github.com/yanhaiping123/hexo-hepel-blog"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yanhaiping123/hexo-hepel-blog" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI3MTYyMTQ1MA==&amp;action=getalbum&amp;album_id=2970145616205037574#wechat_redirect" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">函数与程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">一、作用域的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E5%8F%AB%E5%81%9A%E5%AF%B9%E4%BA%8E%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%8C%BA%E5%9F%9F%E7%9A%84%E8%AF%86%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.0.0.1.</span> <span class="toc-text">1、什么叫做对于定义的变量作用区域的识别？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">二、函数的定义和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89%E5%87%BD%E6%95%B0%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">三、为什么一定要有函数结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E5%8F%82%E4%B8%8E%E5%BD%A2%E5%8F%82%EF%BC%88%E7%9C%9F%E5%81%87%E5%AD%99%E6%82%9F%E7%A9%BA%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">四、实参与形参（真假孙悟空）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%BD%A2%E5%8F%82%E7%9A%84%E6%89%80%E6%9C%89%E6%94%B9%E5%8F%98%E9%83%BD%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%AE%9E%E5%8F%82%E7%9A%84%E5%80%BC%E3%80%82"><span class="toc-number">1.4.0.0.1.</span> <span class="toc-text">注意：形参的所有改变都不会改变实参的值。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">1.5.</span> <span class="toc-text">五、函数的定义与声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E8%AE%B2%E8%A7%A3%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">六、递归函数（基础讲解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%86%E6%9E%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">1、分析斐波那契数列函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">2、欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E4%B9%89%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">3、递归函数的终极奥义（难点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1）数学归纳法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2）递归函数设计的三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%88%A9%E7%94%A8%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3）利用递归求阶乘</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-number">1.7.</span> <span class="toc-text">七、关于函数的扩展知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">1、扩展欧几里得算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%9D%E7%A5%96%E7%AD%89%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">什么是贝祖等式？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%9D%E7%A5%96%E7%AD%89%E5%BC%8F%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.7.1.1.1.</span> <span class="toc-text">贝祖等式的形式如下：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">2、变参函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B9%9F%E6%98%AF%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">3、主函数也是有参数的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%8C%E8%99%BD%E7%84%B6%E4%B8%BB%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E9%83%BD%E6%94%AF%E6%8C%81%E8%BF%99%E7%A7%8D%E7%89%B9%E6%80%A7%E3%80%82%E5%9C%A8%E4%B8%80%E4%BA%9B%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%88%96%E8%80%85%E6%9F%90%E4%BA%9B%E7%89%B9%E5%AE%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%8C%E4%B8%BB%E5%87%BD%E6%95%B0%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%8E%A5%E5%8F%97%E4%BB%BB%E4%BD%95%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-number">1.7.3.0.1.</span> <span class="toc-text">注意，虽然主函数可以有参数，但并不是所有的编程环境都支持这种特性。在一些嵌入式系统或者某些特定的编程环境中，主函数可能不接受任何参数。</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yanhaiping123/hexo-hepel-blog/2024/08/08/Functions%20and%20program%20structures/" title="C语言基础——浅谈函数及程序结构">C语言基础——浅谈函数及程序结构</a><time datetime="2024-08-08T06:37:18.046Z" title="Created 2024-08-08 14:37:18">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yanhaiping123/hexo-hepel-blog/2024/08/07/hello-world/" title="Welcome to XingHai!">Welcome to XingHai!</a><time datetime="2024-08-07T14:19:16.115Z" title="Created 2024-08-07 22:19:16">2024-08-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Hepel Yan</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello, welcome to my <a href="https://github.com/yanhaiping123/hexo-hepel-blog">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/yanhaiping123/hexo-hepel-blog/js/utils.js?v=4.13.0"></script><script src="/yanhaiping123/hexo-hepel-blog/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://github.com/yanhaiping123/hexo-hepel-blog/2024/08/08/Functions%20and%20program%20structures/'
    this.page.identifier = '/yanhaiping123/hexo-hepel-blog/2024/08/08/Functions%20and%20program%20structures/'
    this.page.title = 'C语言基础——浅谈函数及程序结构'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>